# Implementation Plan: Chat API & Persistence Contract

**Branch**: `003-chat-api-persistence`
**Date**: 2025-01-24
**Spec**: [spec.md](./spec.md)
**Input**: SPEC 3.1 — Chat API & Persistence Contract (FOUNDATION)

---

## Summary

Implement the stateless chat lifecycle and database persistence layer for the AI-powered Todo assistant. This plan covers database models (Conversation, Message), FastAPI endpoints, and the persistence boundary — but NOT the MCP tools (Spec 3.2) or agent reasoning logic (Spec 3.3).

---

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: FastAPI, SQLModel, python-jose, Neon PostgreSQL driver
**Storage**: Neon Serverless PostgreSQL (DATABASE_URL)
**Testing**: pytest, pytest-asyncio, httpx
**Target Platform**: Linux server (Vercel/Railway compatible)
**Project Type**: Web application (backend)
**Performance Goals**: < 4 seconds p95 latency, 100 concurrent requests
**Constraints**: Stateless (no in-memory state), user isolation mandatory

---

## Constitution Check

**GATE: Must pass before implementation. All items from Constitution v2.0.0.**

| Principle | Requirement | Plan Compliance |
|-----------|-------------|-----------------|
| §3.1 User Isolation | All queries filter by user_id | ✅ All CRUD operations include user_id filter |
| §3.2 Stateless Server | No in-memory state | ✅ All state loaded from/saved to PostgreSQL |
| §3.3 No Silent Failures | Friendly error messages | ✅ Standardized error response format |
| §3.4 Auth Boundary | Verify user_id === JWT | ✅ Middleware validates before processing |
| §3.5 Natural Language | No IDs exposed to user | ✅ IDs only in API responses, not chat content |

**Result**: ✅ All gates pass

---

## Project Structure

### Documentation (this feature)

```
specs/003-chat-api-persistence/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Technical decisions
├── data-model.md        # Entity definitions
├── contracts/           # API contracts
│   └── chat-api.md      # Endpoint definitions
├── checklists/
│   └── requirements.md  # Quality validation
└── tasks.md             # Implementation tasks (generated by /sp.tasks)
```

### Source Code

```
backend/
├── app/
│   ├── models/
│   │   ├── __init__.py
│   │   ├── conversation.py    # Conversation SQLModel
│   │   └── message.py         # Message SQLModel
│   ├── crud/
│   │   └── conversation.py    # CRUD operations
│   ├── api/
│   │   └── chat.py            # Chat endpoints router
│   ├── schemas/
│   │   └── chat.py            # Pydantic request/response
│   ├── services/
│   │   └── agent_interface.py # Abstract agent runner
│   └── database.py            # DB session management
├── alembic/
│   └── versions/
│       └── 003_create_conversations.py  # Migration
└── tests/
    └── integration/
        └── test_chat.py       # Integration tests
```

---

## Implementation Steps

### Phase 1: Database Layer (Steps 1-4)

#### Step 1: Create Conversation Model

**Responsibility**: Define SQLModel class for Conversation entity

**Details**:
- File: `backend/app/models/conversation.py`
- Fields: id (UUID), user_id, title, created_at, updated_at
- Relationship: has_many Messages with cascade delete
- Indexes: user_id, (user_id, updated_at)

**Constitution Alignment**: §3.1 (user_id indexed for isolation queries)

---

#### Step 2: Create Message Model

**Responsibility**: Define SQLModel class for Message entity

**Details**:
- File: `backend/app/models/message.py`
- Fields: id (UUID), conversation_id (FK), user_id, role, content, tool_calls, tool_results, created_at
- Relationship: belongs_to Conversation
- Indexes: conversation_id, (conversation_id, created_at), user_id
- Validation: role in ("user", "assistant"), content not empty, max 10000 chars

**Constitution Alignment**: §3.1 (user_id denormalized for direct queries)

---

#### Step 3: Create Alembic Migration

**Responsibility**: Database schema migration for new tables

**Details**:
- File: `backend/alembic/versions/003_create_conversations.py`
- Create conversations table with indexes
- Create messages table with FK and indexes
- Reversible: include downgrade() to drop tables

**Constitution Alignment**: §3.2 (all state in PostgreSQL)

---

#### Step 4: Create CRUD Operations

**Responsibility**: Database access functions for conversations and messages

**Details**:
- File: `backend/app/crud/conversation.py`
- Functions:
  - `create_conversation(user_id, title=None) → Conversation`
  - `get_conversation(conversation_id, user_id) → Conversation | None`
  - `get_conversation_with_messages(conversation_id, user_id) → Conversation`
  - `list_conversations(user_id, limit, offset) → List[Conversation]`
  - `delete_conversation(conversation_id, user_id) → bool`
  - `add_message(conversation_id, user_id, role, content, tool_calls=None) → Message`
  - `get_messages(conversation_id, user_id, limit=100) → List[Message]`
  - `update_conversation_timestamp(conversation_id, user_id) → None`
- ALL functions MUST include user_id parameter for isolation

**Constitution Alignment**: §3.1 (mandatory user_id filtering)

---

### Phase 2: API Layer (Steps 5-8)

#### Step 5: Create Request/Response Schemas

**Responsibility**: Pydantic models for API validation

**Details**:
- File: `backend/app/schemas/chat.py`
- Request schemas:
  - `ChatRequest`: message (str, required), conversation_id (str, optional)
  - Message validation: 1-10000 chars, not whitespace-only
- Response schemas:
  - `ChatResponse`: conversation_id, user_message_id, assistant_message_id, response
  - `ConversationListResponse`: conversations[], total
  - `ConversationDetailResponse`: id, title, created_at, updated_at, messages[]
  - `ErrorResponse`: error (code), message (user-friendly)

**Constitution Alignment**: §3.3 (standardized error format)

---

#### Step 6: Create Auth Dependency

**Responsibility**: JWT verification and user_id validation

**Details**:
- File: `backend/app/api/deps.py` (or extend existing)
- Dependency: `verify_user(user_id: str, token: JWT) → str`
- Verify JWT is valid (existing Phase II logic)
- Verify path {user_id} matches JWT user_id
- Return 401 for invalid token, 403 for mismatch

**Constitution Alignment**: §3.4 (auth boundary respected)

---

#### Step 7: Create Agent Interface (Abstract)

**Responsibility**: Define boundary for agent execution

**Details**:
- File: `backend/app/services/agent_interface.py`
- Abstract class or protocol: `AgentRunner`
- Method: `process(messages: List[dict]) → str`
- Stub implementation for testing (returns echo or placeholder)
- **NOTE**: Real implementation in Spec 3.3

**Integration Point**: Spec 3.3 will implement the actual agent logic

---

#### Step 8: Create Chat Endpoints Router

**Responsibility**: FastAPI router with all chat endpoints

**Details**:
- File: `backend/app/api/chat.py`
- Endpoints:
  - `POST /api/{user_id}/chat` - Send message
  - `GET /api/{user_id}/conversations` - List conversations
  - `GET /api/{user_id}/conversations/{conversation_id}` - Get detail
  - `DELETE /api/{user_id}/conversations/{conversation_id}` - Delete
- Each endpoint:
  - Validates auth via dependency
  - Calls CRUD functions
  - Returns standardized response/error

**Request Lifecycle (POST /chat)**:
1. Verify JWT and user_id match
2. Validate request body (message not empty, length)
3. If conversation_id provided → load or 404
4. If no conversation_id → create new conversation
5. Persist user message to database
6. Load conversation history from database
7. Build message array for agent
8. Call agent interface (stub for now)
9. Persist assistant response to database
10. Update conversation.updated_at
11. Return response with all IDs

**Constitution Alignment**: §3.2 (stateless - all state from DB), §3.3 (error handling)

---

### Phase 3: Error Handling (Steps 9-10)

#### Step 9: Create Error Handler

**Responsibility**: Centralized error handling for chat endpoints

**Details**:
- File: `backend/app/api/errors.py`
- Exception classes:
  - `ConversationNotFoundError`
  - `InvalidMessageError`
  - `MessageTooLongError`
- Exception handlers that return ErrorResponse format
- Log technical details server-side, return friendly message to user

**Constitution Alignment**: §3.3 (no silent failures, no technical leakage)

---

#### Step 10: Register Router and Error Handlers

**Responsibility**: Wire everything into FastAPI app

**Details**:
- File: `backend/app/main.py` (modify)
- Include chat router at `/api/{user_id}`
- Register exception handlers
- Ensure CORS configured for frontend

---

### Phase 4: Testing (Steps 11-12)

#### Step 11: Create Integration Tests

**Responsibility**: Test full request lifecycle

**Details**:
- File: `backend/tests/integration/test_chat.py`
- Test cases:
  - Send message creates conversation
  - Send message to existing conversation
  - Empty message returns 400
  - Wrong user_id returns 403
  - Invalid conversation_id returns 404
  - Conversation persists after "restart" (new session)
  - List conversations returns correct data
  - Delete conversation removes all messages

**Constitution Alignment**: §3.2 (verify stateless behavior)

---

#### Step 12: Create Persistence Tests

**Responsibility**: Verify data integrity and isolation

**Details**:
- File: `backend/tests/integration/test_persistence.py`
- Test cases:
  - User A cannot see User B's conversations
  - Message order preserved across sessions
  - Tool calls/results stored and retrieved correctly
  - Cascade delete removes messages

**Constitution Alignment**: §3.1 (verify user isolation)

---

## Dependencies & Execution Order

```
Step 1 (Conversation Model)    ──┐
Step 2 (Message Model)         ──┼──→ Step 3 (Migration) ──→ Step 4 (CRUD)
                                 │
Step 5 (Schemas)               ──┼──→ Step 8 (Endpoints)
Step 6 (Auth Dependency)       ──┤
Step 7 (Agent Interface)       ──┘
                                      │
Step 9 (Error Handler) ───────────────┤
                                      │
Step 10 (Register) ───────────────────┘
                                      │
                                      ▼
Step 11 (Integration Tests) ←─────────┘
Step 12 (Persistence Tests)
```

**Parallel Opportunities**:
- Steps 1, 2 can run in parallel (models)
- Steps 5, 6, 7 can run in parallel (schemas, auth, interface)
- Steps 11, 12 can run in parallel (tests)

---

## Integration Points for Later Specs

| This Spec | Interface | Later Spec |
|-----------|-----------|------------|
| AgentRunner.process() | Abstract method | 3.3 - Agent Loop |
| Message.tool_calls | JSON storage | 3.2 - MCP Tools |
| Message.tool_results | JSON storage | 3.2 - MCP Tools |

---

## Idempotency & Stateless Guarantees

1. **UUID Generation**: Client can generate IDs client-side for retry safety
2. **No Server State**: Each request loads ALL context from database
3. **Atomic Operations**: Message insert + timestamp update in single transaction
4. **Restart Survival**: All data in PostgreSQL, nothing lost on restart

---

## Migration Strategy

1. Run `alembic upgrade head` to apply migration
2. New tables created: conversations, messages
3. No data migration needed (new tables)
4. Rollback: `alembic downgrade -1` drops tables

---

## Complexity Tracking

No constitution violations requiring justification. Plan follows all principles.

---

## Callouts

⚠️ **Agent Interface is a Stub**: Step 7 creates a placeholder. Real implementation comes from Spec 3.3.

⚠️ **MCP Tools Not Included**: Tool calls are stored but not executed in this spec. Spec 3.2 implements tools.

⚠️ **Rate Limiting Deferred**: Not implemented here. Separate spec will add abuse protection.

---

## Ready for Tasks

This plan is ready for `/sp.tasks` to generate implementable task list.
